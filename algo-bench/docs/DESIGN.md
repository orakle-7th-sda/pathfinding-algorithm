# Bellman-Ford 대비 효율 분석 설계

> 목표: algorithm 폴더의 패스파인딩·복합 알고리즘을 조합해, Bellman-Ford보다 **어떤 경우에** 더 효율적인지 분석하고, 나중에 문서로 정리할 수 있도록 설계를 고정한다.

---

## 1. 효율의 기준 (우선순위)

| 순서 | 기준 | 설명 |
|------|------|------|
| 1 | **실행 결과가 제일 좋은 것** | 찾은 경로의 비용이 최적(최소)인지 |
| 2 | **그걸 충분히 빠르게 주는지** | 실행 시간(레이턴시)이 얼마나 짧은지 |

- 먼저 “같은(또는 더 좋은) 결과”를 보장한 뒤, 그 위에서 “얼마나 빠른지”를 비교한다.

---

## 2. 비교 대상 알고리즘

### 2.1 기준(Baseline)

- **Bellman-Ford** — 단일 출발 최단 경로, 음수 간선 허용. O(VE).

### 2.2 단일 패스파인딩 (이미 구현됨)

| 알고리즘 | 특징 | Bellman-Ford와 비교 시 |
|----------|------|------------------------|
| BFS | 가중치 무시, 간선 수 최소 | 결과 지표가 다름(비용 vs 홉 수). 속도 비교용 참고. |
| DFS | 경로 하나 반환, 최단 비용 비보장 | 참고용. |
| Dijkstra | 양수 간선만, 우선순위 큐 | 양수만 있을 때 결과 동일·속도 비교 대상. |
| A* | 휴리스틱, 양수 간선 | 양수만 있을 때 결과 동일·속도 비교 대상. |

### 2.3 복합 알고리즘 (이미 구현됨)

| 알고리즘 | 하는 일 | Bellman-Ford와 비교 시 |
|----------|---------|------------------------|
| BFS + 거리/경로 테이블 | BFS로 start에서 모든 노드까지 거리·직전 노드 계산 후 경로 복원 | 가중치 무시이므로 “결과(비용)”는 다름. 탐색 범위·속도 참고용. |

### 2.4 조합(복합) 목록 — 확장

아래 조합을 정의하고, 시나리오별로 Bellman-Ford와 결과·속도를 비교한다.

| ID | 조합 이름 | 1단계 | 2단계 | 결과(비용) | 비교 시 |
|----|-----------|-------|-------|------------|---------|
| C1 | BFS → Dijkstra (도달 부분만) | BFS로 start에서 도달 가능한 노드 집합 구함 | 그 노드만으로 부분 그래프 구성 후 Dijkstra | 양수만일 때 최적 | BF 대비 “도달 영역만” 탐색 → 속도·탐색량 비교 |
| C2 | BFS → Bellman-Ford (도달 부분만) | BFS로 도달 가능 노드만 추출 | 부분 그래프에서 Bellman-Ford | BF와 동일(최적) | BF 전체 그래프 vs “부분만” BF → 속도 비교 |
| C3 | BFS 거리 테이블 → 경로 복원 | BFS로 거리·직전 노드 계산 | start–goal 경로 복원 | 비용 무시(홉 수만 최소) | 결과 지표 다름. 속도·탐색량 참고용 |
| C4 | BFS 거리 테이블 → Dijkstra | BFS로 거리(홉 수) 계산 | goal까지 홉 수 상한을 둔 채 Dijkstra (선택) | 양수만일 때 최적 가능 | “홉 제한”이 있으면 결과 다를 수 있음. 실험에서 제한 없으면 C1과 유사 |
| C5 | DFS 경로 존재 → Dijkstra | DFS로 start–goal 도달 여부 확인 | 도달 시에만 Dijkstra 실행 | 양수만일 때 최적 | 불필요한 Dijkstra 호출 방지. 속도 참고 |
| C6 | BFS k-hop 제한 → Bellman-Ford | BFS로 start에서 k홉 이내 노드만 추출 | 그 부분 그래프에서 Bellman-Ford | k가 충분히 크면 최적; 작으면 근사 | BF 전체 vs “제한된 범위” BF. k에 따른 결과·속도 |
| C7 | Dijkstra 단일 / A* 단일 | (단일) Dijkstra 또는 A* | — | 양수만일 때 최적 | 단일 알고리즘 vs BF. 휴리스틱 0이면 A*=Dijkstra |
| C8 | Floyd-Warshall (전체 쌍) | 전체 쌍 최단 경로 한 번 계산 | (start, goal) 쌍만 조회 | 최적 | 한 쌍만 필요할 때 BF vs FW → FW가 무거운 경우 확인 |

- **양수만 시나리오**: C1, C2, C3, C4, C5, C7, C8 적용. 결과 동일(또는 C3/C6은 지표 다름) 확인 후 실행 시간 비교.
- **일부 음수 시나리오**: C2, C6 (Bellman-Ford 사용), C8(FW)만 결과 동일. C1, C4, C5, C7은 부적절.

---

## 3. 시나리오 정의 (명시적 수치)

시나리오를 ID와 수치로 고정해, 재현 가능하게 실험한다.

### 3.1 변수 정의

| 변수 | 기호 | 의미 |
|------|------|------|
| **V** | 노드 수 | 그래프 크기 |
| **E** | 간선 수 | 밀도 반영 (무방향이면 간선 하나당 두 방향 또는 E/2로 계산 방식 통일) |
| **weight_type** | 가중치 종류 | `all_positive` / `some_negative` |
| **graph_shape** | 구조(선택) | `random` / `chain` / `grid` — 1차는 random만 써도 됨 |

### 3.2 시나리오 테이블 (고정값)

| 시나리오 ID | V | E | E/V 대략 | weight_type | 설명 |
|-------------|---|----|----------|-------------|------|
| **S1** | 50 | 150 | 3 | all_positive | 소형, sparse, 양수만 |
| **S2** | 50 | 400 | 8 | all_positive | 소형, 중간 밀도, 양수만 |
| **S3** | 50 | 1 200 | 24 | all_positive | 소형, dense, 양수만 |
| **S4** | 100 | 300 | 3 | all_positive | 중형, sparse, 양수만 |
| **S5** | 100 | 800 | 8 | all_positive | 중형, 중간 밀도, 양수만 |
| **S6** | 100 | 2 500 | 25 | all_positive | 중형, dense, 양수만 |
| **S7** | 200 | 600 | 3 | all_positive | 대형, sparse, 양수만 |
| **S8** | 200 | 1 600 | 8 | all_positive | 대형, 중간 밀도, 양수만 |
| **S9** | 200 | 5 000 | 25 | all_positive | 대형, dense, 양수만 |
| **S10** | 50 | 150 | 3 | some_negative | 소형, sparse, 일부 음수 |
| **S11** | 100 | 300 | 3 | some_negative | 중형, sparse, 일부 음수 |
| **S12** | 200 | 600 | 3 | some_negative | 대형, sparse, 일부 음수 |

- **all_positive**: 간선 가중치 1~10 균일(또는 랜덤).
- **some_negative**: 간선의 약 10~15%를 -5~-1, 나머지 1~10으로 설정 (음수 사이클 없도록 생성 규칙 명시).

### 3.3 시나리오별 “무엇을 비교할지”

| 시나리오 | 결과(비용) 비교 가능 알고리즘 | 실행 시간 비교 대상 |
|----------|------------------------------|---------------------|
| S1~S9 (양수만) | Bellman-Ford, Dijkstra, A*, C1, C2, C4, C5, C7, C8 | 위 모두 + C3(참고) |
| S10~S12 (일부 음수) | Bellman-Ford, C2, C6, C8 | BF, C2, C6, C8. (C1/C4/C5/C7은 최적 비용 미보장) |

---

## 4. 실험 설계

### 4.1 입력

- **그래프 생성**: 시나리오 ID(S1~S12)별로 (V, E, weight_type)에 맞춰 그래프 생성.
  - **all_positive**: 간선 가중치 1~10 균일(또는 랜덤).
  - **some_negative**: 간선의 약 10~15%를 -5~-1, 나머지 1~10. (음수 사이클 없도록 생성 규칙 명시.)
  - 구조: 1차는 `random` (연결성 보장: 예를 들어 0-1-2-…-(V-1) 체인 필수 포함 후 나머지 간선 랜덤).
- **쿼리**: 동일 그래프에 대해 start=0, goal=V-1 고정.

### 4.2 측정

| 순서 | 지표 | 방법 |
|------|------|------|
| 1 | **결과(경로 비용)** | 각 알고리즘의 반환 경로 비용. Bellman-Ford 비용을 “최적”으로 두고, 다른 알고리즘이 같은 비용을 내는지 확인. (양수만: Dijkstra/A*도 최적이어야 함.) |
| 2 | **실행 시간** | 같은 그래프·같은 start/goal에 대해 N회 실행 후 평균(또는 중앙값) 시간(초). |

### 4.3 비교 방식

- **Bellman-Ford 대비 효율**  
  - “결과가 동일(또는 더 좋음)”인 경우에 한정해,  
    - 실행 시간 비율: `t_BF / t_other` (1보다 크면 other가 더 빠름).  
  - **표 1**: 시나리오 ID(S1~S12) × 알고리즘(단일 + 조합 C1~C8) → 비용 일치 여부, 평균 시간(초), BF 대비 시간 비율.  
  - **표 2**: 시나리오 ID × (V, E, weight_type) 요약 — 문서·재현용.

### 4.4 구현 시 사용할 파일

- **알고리즘 구현**: `aggregation_pathfinding_examples.py` (기존 함수 재사용).
- **벤치마크·차트**: `chart_pathfinding.py` 확장 또는 새 스크립트(예: `benchmark_vs_bellman_ford.py`)에서 시나리오·알고리즘 반복 실행, CSV/차트 출력.
- **테스트**: `test_aggregation_pathfinding.py` — 기존처럼 “입력→기대 출력” 검증 유지.

---

## 5. 나중에 문서로 남길 때 구조 (결과 문서 초안)

나중에 “분석 결과 문서”를 쓸 때 아래 순서로 정리하면 된다.

1. **개요**  
   - 목적: Bellman-Ford 대비 효율적인 경우 찾기.  
   - 기준: (1) 실행 결과가 제일 좋은 것, (2) 충분히 빠르게 주는지.

2. **비교 대상**  
   - Baseline: Bellman-Ford.  
   - 단일: BFS, DFS, Dijkstra, A*.  
   - 조합: C1~C8 (BFS→Dijkstra, BFS→BF, BFS 거리→경로, BFS→Dijkstra 홉 제한, DFS→Dijkstra, BFS k-hop→BF, Dijkstra/A*, Floyd-Warshall).  
   - (참고) Naive.

3. **시나리오**  
   - 시나리오 테이블 인용: S1~S12 (V, E, weight_type, 설명). 문서에 표 복사해 두기.

4. **실험 방법**  
   - 그래프 생성 규칙, 쿼리(start/goal), 측정 지표(경로 비용, 실행 시간), 반복 횟수.

5. **결과**  
   - 표: 시나리오 ID(S1~S12) × 알고리즘(단일 + C1~C8) → 비용 일치 여부, 평균 시간, BF 대비 시간 비율.  
   - 차트: 예) x축=시나리오 ID 또는 V, y축=시간(초), 선=Bellman-Ford, Dijkstra, A*, C1, C2, … (선택).

6. **결론**  
   - “양수만 시나리오(S1~S9)에서 Dijkstra/A*/C1/C2가 Bellman-Ford보다 어떤 시나리오에서 몇 배 빠른지.”  
   - “일부 음수 시나리오(S10~S12)에서는 Bellman-Ford(및 C2, C6, C8)만 최적을 보장.”  
   - “조합 C1, C2, … 중 어떤 조합이 어떤 시나리오에서 BF 대비 효율적인지.”

7. **부록**  
   - 코드/스크립트 위치: `aggregation_pathfinding_examples.py`, `chart_pathfinding.py`, `benchmark_vs_bellman_ford.py`(만들 경우).  
   - 실험 환경( Python 버전, 머신 개요).

---

## 6. 다음 단계 (구현 순서 제안)

1. **시나리오별 그래프 생성 함수**  
   시나리오 ID(S1~S12) 또는 (V, E, weight_type) → 인접 리스트 형태 그래프.  
   `chart_pathfinding.py`의 `build_random_graph` 확장 또는 별도 모듈. (연결성 보장, some_negative 시 음수 사이클 없음.)

2. **Bellman-Ford 대비 벤치마크 스크립트**  
   - 시나리오 S1~S12 루프 → 그래프 생성 → Bellman-Ford, Dijkstra, A*, BFS, C1~C8(구현된 것) 실행.  
   - 경로 비용 일치 여부 + 실행 시간 기록 → CSV 저장 (시나리오 ID, 알고리즘, 비용, 시간, BF 대비 비율).

3. **차트**  
   - CSV 기반으로 “시나리오별 BF 대비 시간 비율” 또는 “V에 따른 실행 시간” 차트 생성.

4. **문서 초안**  
   - 위 5번 구조대로 결과를 채워 넣어 `RESULTS.md` 또는 별도 문서로 저장.

이 설계대로 진행하면 “algorithm에서 분석한 알고리즘들을 조합해 Bellman-Ford보다 얼마나 효율적인지”를 재현 가능하게 측정하고, 나중에 문서로 남기기 쉬워진다.
