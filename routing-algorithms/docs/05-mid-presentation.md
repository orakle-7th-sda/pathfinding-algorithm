# DEX Aggregator 알고리즘 — 중간 발표 통합 문서

이 문서는 **테스트 케이스·모델 비교 자료**를 바탕으로, **각 모델 설명**, **테스트 진행 방식**, **데이터 해석**을 하나로 묶어 두었습니다.  
발표자가 이 문서만 보고도 **발표 스크립트**를 만들 수 있도록 구성했으며, **DEX Aggregator 쪽 통상적인 상식**에 맞게 해석했습니다.  
청중 수준을 고려해 **어려운 로직은 쉽게 풀어서** 적었습니다.

---

## 1. 발표 개요 (오프닝용)

**한 줄 요약**  
여러 DEX(탈중앙화 거래소)의 유동성을 한 번에 활용해 “최대한 많이 받는 스왑”을 찾는 **DEX Aggregator**에서 쓰는 **경로 탐색·금액 분할 알고리즘**을 구현하고, 6가지 극한 시나리오로 **9개 모델**을 비교했습니다.

**발표에서 강조할 점**
- **무엇을 했는지**: Single Path 4종 + Composite Path 5종, 총 9개 알고리즘 구현 및 벤치마크.
- **어떻게 검증했는지**: Mock 풀 데이터로 6개 시나리오 구성, 동일 입력에 대해 9개 알고리즘을 동시 실행해 출력량·실행 시간 비교.
- **무엇을 알 수 있는지**: 거래 규모·유동성 구조에 따라 “한 경로만 쓰기” vs “여러 풀에 나누기”, “균등 분할” vs “유동성 고려 분할”의 차이가 결과에 어떻게 드러나는지.

---

## 2. DEX Aggregator란? (배경 — 청중용)

**쉬운 설명**
- 사용자가 “ETH 100개를 USDC로 바꿔 달라”고 하면, **한 개 DEX**만 쓰지 않고 **여러 DEX의 풀**을 함께 보면서, “어디를 얼마나 써야 받는 USDC가 최대인지”를 계산해 주는 게 Aggregator의 역할입니다.
- **한 경로만 고르는 것**(예: Uniswap 풀 하나만 사용)과 **여러 풀에 금액을 나눠 넣는 것**(스플릿)을 모두 고려할 수 있습니다.
- 실무에서도 “대량 거래일수록 한 풀에 다 넣으면 슬리피지가 커지므로, 여러 풀에 나누는 편이 유리하다”는 식의 상식이 널리 쓰입니다. 우리 실험은 이 상식이 수치로 어떻게 나타나는지 보여 줍니다.

**발표 시 사용할 수 있는 문장**  
“DEX Aggregator는 여러 DEX의 유동성을 묶어서, 사용자가 한 번에 스왑할 때 받는 양을 최대화해 주는 서비스입니다. 오늘은 그 안에서 쓰이는 경로 탐색·금액 분할 알고리즘 9가지를 구현하고, 6가지 시나리오로 비교한 결과를 공유하겠습니다.”

---

## 3. 구현한 모델 소개 (쉽게)

우리 프로젝트는 **Single Path**(한 경로만 선택) 4종과 **Composite Path**(분할 또는 멀티홉) 5종, 총 **9개** 알고리즘을 구현했습니다.

### 3.1 Single Path (한 경로만 선택)

| 모델 | 쉬운 개념 | Aggregator 관점에서의 의미 |
|------|-----------|----------------------------|
| **Naive Brute Force** | 가능한 경로를 여러 개 열거한 뒤, “실제로 받는 양”이 최대인 경로 하나를 고른다. | 베이스라인. “이 금액으로 진짜 최대로 받는 단일 경로”를 찾는 기준이 됨. |
| **BFS Routing** | “거쳐 가는 풀(홉) 수”만 최소로 만든다. 가격·슬리피지는 보지 않는다. | 홉 수 최소화 = 가스 비용 감소에 유리. 대신 받는 양은 최적이 아닐 수 있음. |
| **Dijkstra Routing** | “순간 가격(spot price)”이 가장 좋은 경로를 찾는다. | 소액·마진 거래에 맞는 경로. 대량이면 슬리피지 때문에 실제 받는 양은 Naive보다 낮을 수 있음. |
| **A* Search Routing** | Dijkstra와 같은 “순간 가격 기준”이지만, 휴리스틱으로 탐색 범위를 줄인다. | 목표와 성향은 Dijkstra와 비슷. 대량 거래 시 실제 출력은 Naive·MultiHop보다 낮을 수 있음. |

**발표용 한 줄**  
“Single Path는 **한 개의 경로(한 개 또는 몇 개 풀을 연속으로)**만 정해서 그 경로로 전부 스왑합니다. Naive는 ‘실제 받는 양’ 기준, BFS는 ‘홉 수’ 기준, Dijkstra와 A*는 ‘순간 가격’ 기준으로 경로를 고릅니다.”

### 3.2 Composite Path (분할 또는 멀티홉)

| 모델 | 쉬운 개념 | Aggregator 관점에서의 의미 |
|------|-----------|----------------------------|
| **Simple Split** | 같은 토큰 쌍(예: ETH–USDC)의 **모든 풀에 금액을 똑같이** 나눠 넣는다. | 구현이 단순하고 슬리피지 분산에는 도움. 유동성이 한쪽으로 치우쳐 있으면 불리. |
| **Greedy Split** | 금액을 작은 단위(청크)로 나눠서, “지금 이 청크를 넣었을 때 받는 양이 가장 많이 늘어나는 풀”에 순서대로 넣는다. | 유동성·비율을 반영. 실무에서 자주 쓰이는 “출력과 속도의 균형” 타입. |
| **Multi-Hop Routing** | 직통(ETH→USDC)뿐 아니라 중간 토큰을 거치는 경로(ETH→WBTC→USDC)까지 고려해, **실제 받는 양이 최대인 단일 경로** 하나를 고른다. | 직통 풀이 없거나 비율이 나쁠 때 유리. 단일 경로이므로 “분할”은 아님. |
| **DP Split Routing** | 입력 금액을 이산 단위로 쪼개고, “어느 풀에 얼마씩 넣을지”를 동적 프로그래밍으로 최적화한다. | 이론에 가까운 “거의 최적” 분할. 풀·스텝 수가 많으면 계산 비용이 커짐. |
| **Convex Optimization Split** | 풀별 할당량을 연속 변수로 두고, “총 받는 양”을 최대화하는 볼록 최적화를 푼다. | 이론적으로 AMM에 맞는 형태. 출력은 최상위에 가깝고, 실행 시간은 상대적으로 김. |

**발표용 한 줄**  
“Composite는 **여러 풀에 금액을 나누거나**, **중간 토큰을 거치는 경로**를 씁니다. Simple은 균등 분할, Greedy·DP·Convex는 유동성을 고려한 분할, Multi-Hop은 ‘한 경로’이지만 직통이 아닌 경로까지 포함해 최적 경로를 고릅니다.”

---

## 4. 테스트가 어떻게 진행되었는지

### 4.1 데이터와 환경

- **Mock 데이터**: 실제 체인 대신 `DataGenerator(seed=42)`로 **constant product AMM 풀**과 스왑 요청을 생성. 토큰 가격·DEX별 수수료·유동성 배수를 반영.
- **재현성**: 시드 고정으로 동일 시나리오를 반복 실행 가능.
- **공정 비교**: 같은 풀 구성·같은 스왑 요청에 대해 9개 알고리즘을 **같은 환경**에서 순차 실행.

### 4.2 시나리오 6종 (extreme_benchmark.py)

| 시나리오 | 의도 | 풀 구성 | 스왑 |
|----------|------|---------|------|
| Massive Swap (1000 ETH) | 대량 거래 시 성능 차이 확인 | 표준 테스트 풀(31개) | 1000 ETH → USDC |
| Extreme Swap (5000 ETH) | 극대량 거래, 분할 vs 단일 경로 차이 극대화 | 표준 테스트 풀(31개) | 5000 ETH → USDC |
| Low Liquidity Crisis (100 ETH) | 유동성 부족 + 상대적으로 큰 금액 | ETH–USDC/USDT/DAI × 2 DEX, 풀당 10만 USD 수준 | 100 ETH → USDC |
| Imbalanced Liquidity (500 ETH) | 한 DEX만 유동성 큼 → 균등 분할의 한계 | Uniswap 5천만, Sushiswap 50만, Curve 20만 USD | 500 ETH → USDC |
| Many DEXes Split Test (200 ETH) | DEX는 많지만 개별 유동성은 작음 → 분할 효과 | 5개 DEX 각 50만 USD | 200 ETH → USDC |
| Single DEX Only (500 ETH) | 풀 1개만 있을 때 (분할·라우팅 의미 없음) | ETH–USDC 풀 1개(500만 USD) | 500 ETH → USDC |

### 4.3 지표

- **출력량(amount_out)**: 받는 토큰 양. 클수록 좋음.
- **실행 시간(execution_time_ms)**: 알고리즘 연산 시간.
- **베이스라인 대비 개선률(improvement_vs_baseline)**: 베이스라인은 Naive Brute Force. (해당 알고리즘 출력 − 베이스라인 출력) / 베이스라인 출력 × 100 (%).
- **승률**: 6개 시나리오 중 “해당 알고리즘이 출력 1위인 시나리오 수” 비율.

**발표 시 사용할 수 있는 문장**  
“테스트는 **6가지 극한 시나리오**로 진행했습니다. 대량·극대량 거래, 저유동성, 유동성 불균형, DEX 다수·개별 유동성 적음, 단일 DEX만 있는 경우를 넣었고, 각 시나리오마다 **동일한 풀과 스왑 요청**으로 9개 알고리즘을 돌려 출력량과 실행 시간을 비교했습니다.”

---

## 5. 데이터 해석 (Aggregator 상식에 맞게)

해석은 **DEX Aggregator에서 통상 말하는 사실**에 맞춰 두었습니다.  
“대량이면 분할이 유리하다”, “유동성이 한쪽으로 치우치면 균등 분할이 불리하다”, “풀이 하나면 알고리즘 선택은 의미가 없다” 등이 수치로 어떻게 나오는지 정리했습니다.

### 5.1 Extreme Swap (5000 ETH)

- **결과 요약**: Convex/Greedy/DP > Simple Split > Naive/MultiHop > BFS/Dijkstra/A*.
- **해석**  
  - **분할(Simple 이상)**이 **단일 경로(Naive, BFS, Dijkstra, A*, MultiHop)**보다 높은 것은 정상입니다. 5000 ETH를 한 풀에 다 넣으면 슬리피지가 커지고, 여러 풀에 나누면 가격 충격이 분산되기 때문입니다.  
  - **Simple Split이 단일 경로들보다 높은 것**도 정상입니다. Simple은 “균등 분할”만 해도 3개 풀에 나눠 넣어 슬리피지를 줄이므로, “한 경로만 쓰는” 알고리즘보다 받는 양이 많을 수 있습니다.  
  - **BFS/Dijkstra/A***가 Naive·MultiHop보다 **더 낮은** 것도 설계상 자연스럽습니다. BFS는 “홉 수 최소”만 보아 출력 최적이 아니고, Dijkstra/A*는 “순간 가격” 기준 경로를 골라 대량일 때 슬리피지로 실제 출력이 더 떨어질 수 있습니다.
- **발표용 메시지**: “5000 ETH처럼 극대량일 때는 **분할을 쓰는 알고리즘**이 단일 경로보다 훨씬 유리하고, **출력 최대화가 목표가 아닌** BFS·Dijkstra·A*는 더 낮은 출력이 나오는 것이 정상입니다.”

### 5.2 Imbalanced Liquidity (500 ETH)

- **결과 요약**: Convex/Greedy/DP, Naive/BFS/Dijkstra/A*/MultiHop은 거의 비슷(~947–948k). Simple Split만 크게 낮음(~591k).
- **해석**  
  - 한 풀(50M)이 압도적으로 크고 나머지는 작을 때, **최적 전략**은 “대부분을 그 큰 풀에 넣는 것”입니다.  
  - Convex/Greedy/DP는 “어디에 얼마나 넣을지”를 최적화하므로 큰 풀에 몰아주고, 단일 경로들도 “가장 좋은 풀 하나”를 고르므로 같은 큰 풀을 선택합니다. 그래서 **값이 거의 같아지는 것**이 정상입니다.  
  - Simple Split은 **풀 수로 균등 분할**(1/3씩)이라, 작은 풀에도 많이 넣게 되어 **총 출력이 크게 떨어집니다**. Aggregator에서 “유동성이 불균형할 때 균등 분할은 위험하다”는 상식과 일치합니다.
- **발표용 메시지**: “유동성이 **한 DEX에만 몰려 있을 때**는, ‘그 풀만 쓰는’ 알고리즘들은 다 비슷한 결과를 내고, **균등 분할(Simple Split)**만 크게 손해를 보는 구조입니다.”

### 5.3 Low Liquidity Crisis (100 ETH), Many DEXes (200 ETH), Massive Swap (1000 ETH)

- **공통 해석**  
  - **분할(Convex/Greedy/DP)**이 단일 경로보다 유리한 것은 “여러 풀에 나눠 슬리피지를 분산”하는 효과 때문입니다.  
  - **Naive와 MultiHop**이 비슷한 값을 갖는 경우가 많은 것은, 둘 다 “실제 받는 양”을 최대화하는 경로를 고르기 때문입니다. 같은 최적 경로를 고르면 출력이 같아집니다.  
  - **BFS/Dijkstra/A***가 묶여서 비슷한 값을 갖는 경우는, BFS는 “첫 1-hop”, Dijkstra/A*는 “순간 가격 최적” 경로를 쓰는데, 시나리오에 따라 **같은 풀·같은 경로**를 선택할 수 있기 때문입니다. 같은 경로면 출력이 같습니다.
- **발표용 메시지**: “여러 알고리즘이 **묶음으로 비슷한 값**을 갖는 것은, 같은 전략(출력 최대 vs 순간 가격 최적 vs 홉 최소)이 **같은 경로를 선택**했기 때문이며, 로직 오류가 아닌 **정상적인 현상**입니다.”

### 5.4 Single DEX Only (500 ETH)

- **결과**: 모든 알고리즘이 **동일한 출력**.
- **해석**: 풀이 1개뿐이면 “어디로 보낼지·어떻게 나눌지” 선택의 여지가 없습니다. Aggregator 상식과 일치합니다.
- **발표용 메시지**: “DEX가 **하나만 있을 때**는 어떤 알고리즘을 쓰든 받는 양은 같고, 이때는 **속도나 구현 단순성**만 고려하면 됩니다.”

### 5.5 실행 시간

- **요약**: Simple Split·BFS·Dijkstra 등이 가장 빠르고, Greedy가 **속도와 출력의 균형**이 좋으며, DP·Convex는 가장 느리지만 출력은 최상위입니다.
- **해석**: DEX Aggregator에서도 “실시간 응답이 중요하면 Greedy, 최대 출력이 중요하면 Convex/DP”라는 트레이드오프가 통상적으로 말해지는 것과 맞습니다.

---

## 6. 결론 및 시사점 (마무리용)

- **거래 규모가 클수록** 알고리즘 선택에 따른 **출력 차이가 커진다**. (예: 5000 ETH에서 최고·최저 간 큰 격차.)
- **유동성이 부족하거나 불균형할 때** “분할을 쓰는가”, “유동성을 고려해 분할하는가”가 **결과에 큰 영향**을 준다.
- **실무 관점**: 출력과 속도의 균형을 위해 **Greedy Split**을 기본으로 두고, 최대 출력이 더 중요할 때 **Convex** 또는 **DP**를 선택하는 방식이 DEX Aggregator의 통상적 권장과 부합한다.
- **BFS**는 홉 수만 최소화하므로 대량·저유동성에서 출력이 크게 떨어질 수 있어, “받는 양”이 중요할 때는 사용을 피하는 것이 맞다.
- **Simple Split**은 유동성이 비슷할 때만 안전하고, **한쪽으로 치우친 유동성**에서는 Greedy/DP/Convex를 쓰는 것이 맞다.

---

## 7. 발표 스크립트 생성용 요약 (불릿/문장)

아래는 **발표 시 그대로 또는 약간만 바꿔서** 쓸 수 있는 문장·불릿입니다.

**오프닝**  
- “오늘은 DEX Aggregator에서 쓰는 경로 탐색·금액 분할 알고리즘 9가지를 구현하고, 6가지 극한 시나리오로 비교한 결과를 공유하겠습니다.”

**모델 소개**  
- “Single Path 4종은 한 경로만 선택합니다. Naive는 실제 받는 양 최대, BFS는 홉 수 최소, Dijkstra와 A*는 순간 가격 기준 최적 경로를 고릅니다.”  
- “Composite 5종은 여러 풀에 나누거나 중간 토큰을 거치는 경로를 씁니다. Simple은 균등 분할, Greedy·DP·Convex는 유동성을 고려한 분할, Multi-Hop은 최적 단일 경로(직통+멀티홉)를 고릅니다.”

**테스트 설명**  
- “Mock 풀 데이터로 6가지 시나리오를 만들었고, 각 시나리오마다 같은 입력으로 9개 알고리즘을 돌려 출력량과 실행 시간을 비교했습니다.”

**데이터 해석**  
- “대량 거래(5000 ETH)에서는 분할 알고리즘이 단일 경로보다 훨씬 유리했습니다. 한 풀에 다 넣으면 슬리피지가 커지기 때문입니다.”  
- “유동성이 한 DEX에만 몰려 있을 때는, 균등 분할(Simple)만 크게 손해를 보고, 나머지는 비슷한 결과로 수렴했습니다.”  
- “여러 알고리즘이 묶음으로 같은 값을 갖는 것은, 같은 전략이 같은 경로를 선택했기 때문이며 정상입니다.”  
- “풀이 1개일 때는 모든 알고리즘이 동일한 출력을 냈습니다.”

**마무리**  
- “거래 규모와 유동성 구조에 따라 ‘한 경로’ vs ‘분할’, ‘균등 분할’ vs ‘유동성 고려 분할’ 선택이 결과에 큰 영향을 주었고, 실무에서는 Greedy를 기본으로 두고 최대 출력이 중요할 때 Convex·DP를 쓰는 방식이 합리적입니다.”

---

**문서 끝.**  
발표 시에는 `output/extreme_charts/`의 `output_comparison_*.png`, `execution_time_*.png`, `performance_heatmap.png`를 함께 보여 주면, 위 해석을 시각적으로 뒷받침할 수 있습니다.
