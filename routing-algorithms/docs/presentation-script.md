# Bellman-Ford 대비 효율 분석 — 발표 대본 

> 발표 시 읽을 수 있도록 구성한 대본입니다. 슬라이드/차트와 맞춰 사용하세요.

---

## 1. 인사 및 도입 (약 40초)

안녕하세요. 오늘은 **Bellman-Ford 알고리즘을 기준으로**, 다른 패스파인딩·복합 알고리즘이 **어떤 경우에 더 효율적인지** 분석한 결과를 말씀드리겠습니다.

**왜 Bellman-Ford를 기준으로 잡았는지** 말씀드리면, Solana DEX 어그리게이터인 **Jupiter**의 라우팅 엔진 **Metis**가 Bellman-Ford를 크게 변형해서 쓴다고 공식 문서에 나와 있습니다. 최적 스왑 경로를 찾는 데 BF 계열이 쓰인다는 점에서, 우리도 **Bellman-Ford를 기준**으로 두고, 다른 알고리즘이 BF보다 어떤 경우에 더 효율적인지 수치로 정리해 봤습니다.

Bellman-Ford는 음수 간선이 있어도 최단 경로를 구할 수 있는 대표적인 알고리즘입니다. 그래서 **BF보다 언제 어떤 알고리즘이 더 나은지**를 시나리오별·알고리즘별로 측정했습니다.

---

## 2. 목적과 효율 기준 (약 30초)

목적은 두 가지입니다.

첫째, **실행 결과가 제일 좋은 것** — 즉 찾은 경로의 비용이 최적인지입니다.  
둘째, **그걸 충분히 빠르게 주는지** — 실행 시간입니다.

우선 **같은 최적 비용**을 보장한 뒤, 그다음에 **얼마나 빠른지**를 비교했습니다.

---

## 3. 비교 대상과 시나리오 (약 1분)

**기준 알고리즘**은 Bellman-Ford입니다.

**비교한 알고리즘**은 단일로는 **Dijkstra**, **A\***, **BFS**이고, **조합**으로는 **C1, C2, C5, C6, C8**입니다. 각각이 무엇인지는 아래 “3-2. 알고리즘·조합이 무엇인지”에서 정리했습니다.

**시나리오**는 총 12개, **S1부터 S12**까지입니다. 각 시나리오가 무엇인지는 아래 “3-1. 시나리오 S1~S12가 무엇인지”에 모두 적어 두었습니다.

---

### 3-1. 시나리오 S1~S12가 무엇인지

시나리오는 **그래프 크기(V, E)** 와 **가중치 종류(양수만 / 일부 음수)** 로 구분합니다. V는 노드 수, E는 무방향 간선 수입니다.

| 시나리오 ID | V(노드 수) | E(간선 수) | 가중치 | 설명 |
|-------------|------------|------------|--------|------|
| **S1** | 50 | 150 | 양수만 | 소형, sparse(E/V≈3), 양수만 |
| **S2** | 50 | 400 | 양수만 | 소형, 중간 밀도(E/V≈8), 양수만 |
| **S3** | 50 | 1 200 | 양수만 | 소형, dense(E/V≈24), 양수만 |
| **S4** | 100 | 300 | 양수만 | 중형, sparse, 양수만 |
| **S5** | 100 | 800 | 양수만 | 중형, 중간 밀도, 양수만 |
| **S6** | 100 | 2 500 | 양수만 | 중형, dense, 양수만 |
| **S7** | 200 | 600 | 양수만 | 대형, sparse, 양수만 |
| **S8** | 200 | 1 600 | 양수만 | 대형, 중간 밀도, 양수만 |
| **S9** | 200 | 5 000 | 양수만 | 대형, dense, 양수만 |
| **S10** | 50 | 150 | 일부 음수 | 소형, sparse, 간선의 약 10~15%가 음수 |
| **S11** | 100 | 300 | 일부 음수 | 중형, sparse, 일부 음수 |
| **S12** | 200 | 600 | 일부 음수 | 대형, sparse, 일부 음수 |

- **양수만**: 모든 간선 가중치 1~10.  
- **일부 음수**: 간선의 약 10~15%를 -5~-1, 나머지는 1~10. (음수 사이클 없도록 생성.)

---

### 3-2. 비교에 사용하는 알고리즘·조합이 무엇인지

**단일 알고리즘 요약표 (시간·공간 복잡도)**

비교에 쓰는 **단일 알고리즘 네 가지**를 한눈에 보면 아래와 같습니다. 조합(C1, C2 등)은 이 단일 알고리즘들을 어떻게 붙여 쓰는지 아래 “조합(복합) 알고리즘”에서 설명합니다.

**단일 알고리즘 상세 (각각 설명)**

- **Bellman-Ford (기준)**  
  **단일 출발 최단 경로**를 구하는 알고리즘으로, **음수 간선**이 있어도 최단 경로를 구할 수 있는 것이 특징입니다.  
  동작: 모든 간선에 대해 “완화(relaxation)”를 **V-1번** 반복한 뒤, 한 번 더 완화해서 **음수 사이클** 존재 여부를 검사합니다.  
  **시간복잡도 O(V·E)**: V-1번 × 매번 E개 간선 완화. **공간복잡도 O(V)**: 거리·직전 노드 배열 등.  
  한 쌍(start–goal)만 구할 때도 **전체 단일 출발**을 계산하므로, 그래프가 크면 상대적으로 무거울 수 있습니다.

| 알고리즘 | 하는 일 | 시간복잡도 | 공간복잡도 | 조건·비고 |
|----------|---------|------------|------------|-----------|
| **Bellman-Ford** | 단일 출발 최단 경로. **음수 간선** 허용, 음수 사이클 검사 | **O(V·E)** | O(V) | 기준 알고리즘. V-1번 완화 후 1번 더 완화해 사이클 검사. |
| **BFS** | 가중치 무시, **홉 수(간선 개수)** 기준 최단 경로 | **O(V+E)** | O(V) | 비용(가중치 합)은 최적 아님. 큐 사용. |
| **Dijkstra** | 단일 출발 최단 경로. **모든 간선 비음수**일 때만 최적 보장 | **O((V+E) log V)** | O(V) | 우선순위 큐(최소 힙). 음수 간선 있으면 잘못된 결과 가능. |
| **A\*** (A-Star) | 휴리스틱으로 탐색 범위를 줄인 최단 경로 | **최악 O((V+E) log V)** | O(V) | f(n)=g(n)+h(n). h admissible면 최적. h=0이면 Dijkstra와 동일. |

- **BFS (Breadth-First Search)**  
  **너비 우선 탐색**. 간선의 **가중치를 보지 않고**, 시작점에서 도착점까지 **지나가는 간선 개수(홉 수)**가 최소인 경로를 구함. 큐를 쓰고, 같은 “거리(홉 수)” 순으로 퍼져 나감.  
  **시간복잡도**: O(V+E). **공간복잡도**: O(V).  
  가중치 합(비용)은 최소가 아니므로, 우리 실험에서는 “비용 일치” 비교 대상에서 제외함.

- **Dijkstra**  
  **단일 출발 최단 경로**. 시작점에서 모든 노드까지의 **가중치 합이 최소**인 경로를 구함.  
  **조건**: 모든 간선 가중치가 **0 이상**이어야 최적이 보장됨. 음수 간선이 있으면 잘못된 결과를 낼 수 있음.  
  **동작**: 거리가 가장 작은 노드부터 꺼내서 이웃을 “완화”하는 방식. 최소 힙(우선순위 큐)을 쓰면 한 번 꺼낸 노드는 다시 갱신하지 않아도 됨.  
  **시간복잡도**: O((V+E) log V) (힙 기준). **공간복잡도**: O(V).

- **A\*** (A-Star)  
  **휴리스틱**을 사용하는 최단 경로 알고리즘.  
  각 노드 n에 대해 **f(n) = g(n) + h(n)** 을 계산하고, f(n)이 작은 순으로 탐색.  
  - g(n): 시작점에서 n까지의 **실제 비용**  
  - h(n): n에서 도착점까지의 **추정 비용(휴리스틱)**  
  **휴리스틱이 admissible**(실제 비용을 넘지 않음)이면 최적 경로를 보장.  
  **시간복잡도**: 휴리스틱에 따라 다름. h=0이면 Dijkstra와 같아서 O((V+E) log V) 수준. 좋은 휴리스틱이면 탐색 노드 수가 줄어듦. **공간복잡도**: O(V).

---

**조합(복합) 알고리즘**

- **C1 (BFS → Dijkstra, 도달 부분만)**  
  1단계: BFS로 시작점에서 도달 가능한 노드만 구합니다.  
  2단계: 그 노드들만으로 부분 그래프를 만들고, 그 위에서 Dijkstra로 최단 경로를 구합니다.  
  양수만일 때 최적 비용을 주고, “도달 가능한 영역만” 탐색해서 BF 전체 그래프 대비 빠를 수 있습니다.

- **C2 (BFS → Bellman-Ford, 도달 부분만)**  
  1단계: BFS로 도달 가능한 노드만 구합니다.  
  2단계: 그 부분 그래프에서 Bellman-Ford를 돌립니다.  
  BF와 같은 최적 비용을 주고, 전체 그래프가 아니라 부분만 보므로 BF 전체 대비 속도 차이를 비교할 수 있습니다.

- **C5 (DFS → Dijkstra)**  
  1단계: DFS로 시작점에서 도착점까지 도달 가능한지 확인합니다.  
  2단계: 도달 가능할 때만 Dijkstra를 실행합니다.  
  연결 그래프에서는 사실상 Dijkstra만 돌리는 것과 비슷하고, 양수만일 때 최적 비용을 줍니다.

- **C6 (BFS k-hop 제한 → Bellman-Ford)**  
  1단계: BFS로 시작점에서 goal까지의 **홉 수(간선 개수)** d를 구하고, k = d의 2배 같은 상한을 둡니다.  
  2단계: 시작점에서 **k홉 이내** 노드만 모아 부분 그래프를 만들고, 그 위에서 Bellman-Ford를 돌립니다.  
  k가 충분히 크면 최적 경로가 그 부분에 들어가서 BF와 같은 결과를 주고, “제한된 범위만” BF를 돌리는 효과가 있습니다.

- **C8 (Floyd-Warshall)**  
  **전체 쌍** 최단 경로를 한 번에 구하는 알고리즘입니다.  
  우리는 그중 (시작점, 도착점) 한 쌍만 쓰지만, C8은 모든 노드 쌍에 대해 거리를 계산하므로, **한 쌍만 필요할 때**는 Bellman-Ford보다 무거울 수 있습니다.

---

## 4. 실험 방법 (약 20초)

각 시나리오마다 연결 그래프를 만들고, 시작점 0에서 끝점 V-1까지의 최단 경로를  
Bellman-Ford와 위 알고리즘들로 각각 구했습니다.

**측정한 것**은 세 가지입니다.  
경로 비용이 BF와 같은지, 평균 실행 시간, 그리고 **BF 대비 시간 비율**입니다.  
비율이 1보다 크면 그 알고리즘이 BF보다 빠른 것입니다.  
각 (시나리오, 알고리즘) 조합마다 3회씩 돌려서 평균을 냈습니다.

---

## 5. 결과 (약 1분)

**비용 일치**부터 말씀드리면,  
S1부터 S12까지 모든 시나리오에서 Bellman-Ford, Dijkstra, A*, C1, C2, C5, C6, C8은  
**같은 최적 비용**을 냈습니다. BFS는 비용이 아니라 홉 수만 최소화하므로 비용 비교에서는 제외했습니다.

**실행 시간** 쪽 요약입니다.

**양수만** 시나리오, S1~S9에서는  
**Dijkstra**가 Bellman-Ford보다 **24배에서 219배** 빠렸고,  
**A***는 10배에서 182배, **C1**은 6.8배에서 60배, **C5**는 17배에서 173배 빠렸습니다.  
**C2**와 **C6**은 부분 그래프에서 BF를 한 번 더 돌리는 구조라, BF와 비슷하거나 조금 느렸고,  
**Floyd-Warshall, C8**은 한 쌍만 필요할 때는 BF보다 느렸습니다.

**일부 음수** 시나리오, S10~S12에서는  
이번에 만든 그래프에서는 Dijkstra, A*, C1, C5도 BF와 같은 비용을 냈고, 속도는 여전히 빨랐지만,  
**이론적으로는** 음수 간선이 있으면 Dijkstra·A*는 최적을 보장하지 않으므로,  
실제 서비스에서는 **음수 간선이 있으면 Bellman-Ford나 C2, C6, C8**을 쓰는 것이 안전합니다.

**차트**는 시나리오 ID별로, 알고리즘별 평균 실행 시간을 선으로 그린 것입니다.  
BF와 C8이 위쪽에, Dijkstra·A*·BFS가 아래쪽에 있어서  
한 쌍만 구할 때는 Dijkstra·A* 계열이 훨씬 빠르다는 걸 한눈에 볼 수 있습니다.

---

### 5-1. 차트 설명 (이미지를 띄울 때)

**1) 차트가 제대로 나온 게 맞는지**  
네, 맞습니다. 이 차트는 **시나리오마다 한 점**씩 찍고, 같은 알고리즘끼리 선으로 이은 것입니다.  
시나리오 S1~S12는 **그래프 크기(V, E)**와 **가중치 종류(양수만 / 일부 음수)**가 각각 다릅니다.  
그래서 시나리오가 바뀔 때마다 실행 시간이 오르내리는 것은 **정상**입니다. 선이 울퉁불퉁해 보여도 데이터가 잘못된 것이 아니라, “시나리오별로 조건이 다르다”는 뜻입니다.

**2) 축이 무엇을 의미하는지**

| 축 | 의미 |
|----|------|
| **x축 (가로)** | **시나리오 ID (S1 ~ S12)**. 왼쪽부터 S1, S2, … S12 순서입니다. 각 시나리오는 앞의 “3-1. 시나리오 S1~S12” 표에 나온 대로 **노드 수 V, 간선 수 E, 가중치 종류**가 다릅니다. (예: S1은 V=50, E=150 양수만, S10은 V=50, E=150 일부 음수.) |
| **y축 (세로)** | **평균 실행 시간(초)**. 해당 시나리오에서 해당 알고리즘을 **3회** 돌린 뒤 평균낸 값입니다. 숫자가 **클수록 느린** 알고리즘입니다. |

**3) 차트를 어떻게 읽으면 되는지**  
- **위쪽에 있는 선**일수록 그 알고리즘은 **느립니다**. Bellman-Ford, Floyd-Warshall(C8)이 대체로 위쪽에 있습니다.  
- **아래쪽에 있는 선**일수록 **빠릅니다**. Dijkstra, A*, BFS, C1, C5가 아래쪽에 모여 있습니다.  
- **같은 시나리오(같은 x)**에서 선들이 **세로로 얼마나 떨어져 있는지** 보면, 그 시나리오에서 알고리즘 간 **속도 차이**를 비교할 수 있습니다.  
- S1~S9는 양수만, S10~S12는 일부 음수 시나리오이므로, “양수만 구간”과 “일부 음수 구간”에서 선들이 어떻게 달라지는지도 볼 수 있습니다.

---

## 6. 결론 (약 40초)

정리하면 세 가지입니다.

**첫째**, **가중치가 모두 양수일 때**는  
Dijkstra, A*, C1, C5가 Bellman-Ford보다 **수십 배 빠르면서도** 같은 최적 비용을 주었습니다.  
그래서 이럴 때는 BF 대신 Dijkstra나 A*를 쓰는 것이 효율적입니다.

**둘째**, **음수 간선이 있을 때**는  
최적 비용을 보장하려면 Bellman-Ford, 또는 C2·C6·C8처럼 BF를 쓰는 조합을 써야 하고,  
Dijkstra·A*·C1·C5는 일반적으로 사용하지 않는 것이 좋습니다.

**셋째**, **조합** 중에서는  
**C1**, BFS 후 Dijkstra가 양수만일 때 BF 대비 6.8~60배 빠르고 비용도 동일해서  
“도달 가능한 부분만 잘라서 Dijkstra” 전략이 잘 먹힌다는 걸 수치로 확인했습니다.

---

## 7. 마무리 (약 10초)

이상으로 Bellman-Ford를 기준으로 한 효율 분석 결과를 말씀드렸습니다.  
자료와 코드는 프로젝트 폴더의 docs/(RESULTS.md, DESIGN.md), data/benchmark_vs_bellman_ford.csv를 참고해 주시면 됩니다. 감사합니다.
